---
title: "From Prompt to Production: Why Developers Still Ship"
publishedAt: "2025-10-04"
summary: "I built two real apps in frameworks I'd never touched—using generative AI. Here’s what AI does well, and where engineering judgment still wins."
description: "From scaffolding to shipping: CI/CD, runtime debugging, and architecture are still human advantages—even when AI writes the first draft."
image: "/ai_vs_developer.png"
# tags: ["ai", "nextjs", "swiftui", "dsa", "engineering"]
---

## My Week: Two Apps Built, Using AI where it helps

This week, I challenged myself to build two real-world apps in frameworks I hadn't used:

✅ An **iOS app** without writing a single line of **SwiftUI**  
✅ A **web app** without prior **Next.js** experience

Check them out:

- 📱 iOS App (SwiftUI): [github.com/TheAnandThakkar/anandthakkar-swiftUI](https://github.com/TheAnandThakkar/anandthakkar-swiftUI)
- 🌐 Web App (Next.js): [github.com/TheAnandThakkar/anandthakkar-nextJS](https://github.com/TheAnandThakkar/anandthakkar-nextJS)

How? The same way many are building now—**Generative AI**.

AI scaffolded projects, translated ideas to code, and produced UI components. It felt magical—but it also revealed a core truth about software development.

---

## ⚙️ The Gap Between “Code Generated” and “Product Deployed”

AI can write code, but getting to a **running, scalable product** still needs a developer.

Even in this experiment, several steps required engineering judgment:

### 1) The CI/CD Labyrinth

AI won’t wire your pipelines, deploy keys, or env vars. Shipping with GitHub Actions (or similar), managing secrets, and automating releases is still on you.

### 2) The Runtime Riddle

When runtime bugs, dependency conflicts, or memory/CPU spikes happen, debugging instincts matter more than prompts.

### 3) The Architectural Blueprint

AI can build a house; it doesn’t decide how rooms connect. API boundaries, state management, scaling strategy—these are human choices.

These aren’t mere coding tasks. They’re **engineering**.

---

## 🧠 Why Fundamentals Still Win

What made this workable for me was prior grounding in **OOP**, **abstraction**, and **software design**.

When AI generated SwiftUI/Next.js code, I could see what it did, what might break, and what to refactor.

That’s why **Data Structures & Algorithms (DSA)** remain relevant:

- ⚡ **Performance awareness:** Is this O(n²) when O(n log n) exists?
- 🧩 **Right data model:** HashMap vs Tree vs Graph?
- 🚀 **Scalability:** Will it hold at 10k concurrent users?

AI delivers the _what_. Fundamentals give you the _why_.

---

## 🧩 Experience: The Unfair Advantage

AI is improving fast. But durable systems still need **context, trade-off thinking, and accountability**.

The developer’s value is shifting from:

> “I can write code”  
> to  
> “I can debug, deploy, and design systems that last.”

AI is a phenomenal tool. Tools don’t build great systems—**craftspeople do**.  
The best craftspeople have battled real systems, real bugs, real deadlines.

**Experience will continue to ship products.**
